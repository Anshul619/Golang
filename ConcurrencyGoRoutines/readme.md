# Concurrency in GoLang
- Go provides very good support for concurrency using [Go Routines or channels](https://go.dev/tour/concurrency/1).
- It takes advantage of efficient memory management strategies and [multicore processor architecture](https://www.techtarget.com/searchdatacenter/definition/multi-core-processor) for implementing concurrency.

# Constructs

| Construct                                      | Package | Description                                                                                                                                                                                                                                                                                                            | Sample Code                                                                                                                                                                                                                                                                                               |
|------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Mutex](https://gobyexample.com/mutexes)       | sync    | We can use a mutex to safely access data across multiple goroutines.<br/>- Lock the mutex before accessing counters; unlock it at the end of the function using a defer statement.<br/>- sync.RWMutex lets multiple goroutines read simultaneously (via RLock), but still enforces exclusive access for writes (Lock). | type Test struct { mu sync.Mutex }<br/>- c.mu.Lock()<br/>- defer c.mu.Unlock()<br/>- c.counter++                                                                                                                                                                                                          |
| [WaitGroup](https://pkg.go.dev/sync#WaitGroup) | sync    | A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add() to set the number of goroutines to wait for.                                                                                                                                                                                  | var wg sync.WaitGroup<br/>- `wg.Add(1)` // Always call wg.Add() before you launch the goroutine that will call wg.Done().<br/>- `wg.Done()` //Recommended to call WaitGroup.Done() deferred, so it gets called even if the goroutine panics.<br/>- `wg.Wait()` //wg.Wait() will block until wg.Done() is called. |
| [Once](https://pkg.go.dev/sync#Once)           | sync    | Once is an object that will perform exactly one action.                                                                                                                                                                                                                                                                | var once sync.Once<br/>- once.Do(func() {singleInstance = new(single)})                                                                                                                                                                                                                                   |

# GoRoutines
- [A Goroutine](https://go.dev/tour/concurrency/1) is a function or method which executes independently and simultaneously in connection with any other Goroutines present in your program. ([asynchronous function execution](https://medium.com/@gauravsingharoy/asynchronous-programming-with-go-546b96cd50c1))
- Goroutines, can be very cheap (light weighted thread): they have little overhead beyond the memory for the stack, which is just a few kilobytes.
- All the Goroutines are working under the main Goroutines if the main Goroutine terminated, then all the goroutine present in the program also terminated. Goroutine always works in the background.
- When a new Goroutine executed, the Goroutine call return immediately. 
- The control does not wait for Goroutine to complete their execution just like normal function they always move forward to the next line after the Goroutine call and ignores the value returned by the Goroutine.
- Goroutines can communicate using the [channel](Channels/Readme.md) and these [channels](Channels/Readme.md) are specially designed to prevent race conditions when accessing shared memory using Goroutines.

# References
- [Go Concurrency Patterns: Timing out, moving on](https://go.dev/blog/concurrency-timeouts)
- [Crack the top 50 Golang interview questions](https://www.educative.io/blog/50-golang-interview-questions)
- [Goroutine Leaks - The Forgotten Sender](https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html)
- [Mutex in Golang](https://golangdocs.com/mutex-in-golang)
- [Why is my goroutine not executed?](https://stackoverflow.com/questions/24425987/why-is-my-goroutine-not-executed)
- [A little about Goroutines in Go!](https://dev.to/jeffotoni/a-little-about-goroutines-in-go-2f0f)
