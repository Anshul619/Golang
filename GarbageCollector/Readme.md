# Garbage Collector in Go

| Question                                                                                                     | Answer                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| How does the garbage collector work?                                                                         | Go's garbage collector uses a non-generational concurrent tricolor mark-and-sweep algorithm. <br/>- It runs mostly concurrently with the application, minimizing stop-the-world pauses. <br/>- The tricolor marking categorizes objects as white (unreachable), gray (reachable but not fully scanned), or black (reachable and scanned). <br/>- The GC starts by marking root objects gray, traverses their references, and eventually sweeps unmarked (white) objects. |
| What impact does it have on high-performance applications?                                                   | GC has been optimized for low latency, with sub-millisecond pause times in most cases. <br/>- It interleaves GC work with application goroutines, so pauses are usually tied to STW phases for things like stack scanning.                                                                                                                                                                                                                                               |
| How can you tune or work around GC to reduce latency in systems that require low-latency or high-throughput? | Reducing allocations: e.g., by reusing objects via sync.Pool or buffer pooling.<br/>- Avoiding large object graphs: which can increase GC work<br/>- Tuning GOGC: The GOGC environment variable controls the growth factor of the heap before triggering GC. Lowering it means more frequent collections, higher means fewer but larger collections.<br/>- Profiling allocations: Using pprof and runtime.ReadMemStats to understand allocation hotspots.                |
| How to tune for high sensitive environment? (ex - trading system)                                            | Use arena allocation, or design critical code paths to be GC-neutral (preallocating buffers or using native memory via unsafe or C interop).                                                                                                                                                                                                                                                                                                                             |